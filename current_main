clearvars
close all
clc

cd('D:\');
Metadata;

addpath('D:\Co-Registration\Functions');

% Load the STL files
%mesh1 = ft_read_headshape('C:\Users\mschmidt\Desktop\Optical Scan\20_06_24\loc2.stl');
mesh1 = ft_read_headshape('C:\Users\mschmidt\OneDrive - University College London\blender edits\headcast_OP00169.stl');
mesh2 = ft_read_headshape('D:\Co-Registration\Co-registratoin\MRI_tidy.stl');
spinal_cord = ft_read_headshape('C:\Users\mschmidt\OneDrive - University College London\SpinalCord\segmentation_results\sub-A006_T1w_mesh.stl');

% make fieldtrip imported files spm compatible
spm_mesh1 = struct();
spm_mesh1.vertices = mesh1.pos;  
spm_mesh1.faces = mesh1.tri;     

spm_mesh2 = struct();
spm_mesh2.vertices = mesh2.pos;
spm_mesh2.faces = mesh2.tri;

spm_spinalcord = struct();
spm_spinalcord.vertices = spinal_cord.pos;
spm_spinalcord.faces = spinal_cord.tri;

% downsample to make it fast for processing
mesh1_ds = reducepatch(spm_mesh1, 0.5);
mesh2_ds = reducepatch(spm_mesh2, 0.3);
spinalcord_ds = reducepatch(spm_spinalcord, 0.5);

% select fiducials for scale factor calculation
fprintf('Select fiducials on mesh1 (nose, chin and adams apple)\n');
fiducials_1 = spm_mesh_select(mesh1_ds); 

fprintf('Select fiducials on mesh2 (nose, chin and adams apple)\n');
fiducials_2 = spm_mesh_select(mesh2_ds); 

mesh1_scale = fiducials_1';  
mesh2_scale = fiducials_2'; 

% select fiducials for coregistration of MRI and Optical Scan
fprintf('Select fiducials on mesh1 (left shoulder, right shoulder, nose, chin and adams apple)\n'); 
fiducials1 = spm_mesh_select(mesh1_ds, 5);

fprintf('Select fiducials on mesh2 (left shoulder, right shoulder, nose, chin and adams apple)\n'); %MRI is mirrored - so left on MRI is right on optical
fiducials2 = spm_mesh_select(mesh2_ds, 5);

mesh1_fids = fiducials1';
mesh2_fids = fiducials2';
select fiducials for coregistration of MRI and Spinal Cord
fprintf('Select fiducials on MRI (centerline at brain stem and inflection)'); %will need to look to alter fid points
spin_fids_1 = spm_mesh_select(mesh2_ds, 2);

fprintf('Select fiducials on Spinal Cord (top and inflection)');
spin_fids_2 = spm_mesh_select(spinalcord_ds, 2);

mri_spin_fids = spin_fids_1';
spine_fids = spin_fids_2';

Scaling 
scale_factor = determine_body_scan_units(mesh1_scale, mesh2_scale);

% Scale the mesh - scale mesh 2 to match mesh 1
mesh1_ds_scaled.vertices = mesh1_ds.vertices;
mesh1_ds_scaled.faces = mesh1_ds.faces;

mesh2_ds_scaled.vertices = mesh2_ds.vertices * scale_factor; 
mesh2_ds_scaled.faces = mesh2_ds.faces;

spinalcord_ds_scaled.vertices = spinalcord_ds.vertices * scale_factor;
spinalcord_ds_scaled.faces = spinalcord_ds.faces;

% Scale fiducials
scaled_fiducials1 = mesh1_fids;
scaled_fiducials2 = mesh2_fids * scale_factor;

scaled_fids_mri = mri_spin_fids * scale_factor;
scaled_fids_spine = spine_fids * scale_factor;

% check initial / rough allignment 
% if initial allignmnet is not good, need a better input/ starting point for ICP
% align optical and MRI
[d, Z, transform] = procrustes(scaled_fiducials1, scaled_fiducials2, 'Scaling', false, 'Reflection', true);

initial_transformed_points2 = mesh2_ds_scaled.vertices * transform.T + transform.c(1,:);
initial_transformed_fids2 = scaled_fiducials2 * transform.T + transform.c(1,:);
transformed_fids_mri = scaled_fids_mri * transform.T + transform.c(1,:);

% align MRI and spinal cord
[d, Z, transform] = procrustes(transformed_fids_mri, scaled_fids_spine, 'Scaling', false, 'Reflection', true);

aligned_spine_points = spinalcord_ds_scaled.vertices * transform.T + transform.c(1,:);
aligned_spine_fids = scaled_fids_spine * transform.T + transform.c(1,:);
visualise
figure;
hold on;

trisurf(mesh1_ds_scaled.faces, mesh1_ds_scaled.vertices(:,1), mesh1_ds_scaled.vertices(:,2), mesh1_ds_scaled.vertices(:,3), ...
    'FaceColor', 'cyan', 'FaceAlpha', 0.5, 'EdgeColor', 'none');

trisurf(mesh2_ds_scaled.faces, initial_transformed_points2(:,1), initial_transformed_points2(:,2), initial_transformed_points2(:,3), ...
    'FaceColor', 'magenta', 'FaceAlpha', 0.5, 'EdgeColor', 'none');

trisurf(spinalcord_ds_scaled.faces, aligned_spine_points(:,1), aligned_spine_points(:,2), aligned_spine_points(:,3), ...
   'FaceColor', 'black',   'FaceAlpha', 1, 'EdgeColor', 'none');

scatter3(scaled_fiducials1(:,1), scaled_fiducials1(:,2), scaled_fiducials1(:,3), 100, 'r', 'filled', 'MarkerEdgeColor', 'k');
scatter3(initial_transformed_fids2(:,1), initial_transformed_fids2(:,2), initial_transformed_fids2(:,3), 100, 'b', 'filled', 'MarkerEdgeColor', 'k');

title('Initial Fiducial-Based Alignment');
axis equal;
view(3);
camlight;
lighting gouraud;
hold off;


% Implementing ICP - fid points
% turn the fiducials to point clouds
pc_fiducials1 = pointCloud(scaled_fiducials1);
pc_fiducials2 = pointCloud(initial_transformed_fids2);

% apply ICP to point clouds
tform_fiducials = pcregrigid(pc_fiducials2, pc_fiducials1);

% apply icp transform to the whole mesh
transformed_fids2 = transformPointsForward(tform_fiducials, initial_transformed_fids2);
transformed_vertices2 = transformPointsForward(tform_fiducials, initial_transformed_points2);

mesh2_final = mesh2_ds_scaled;
mesh2_final.vertices = transformed_vertices2;

% check coords of fids
fprintf('Fiducial coordinates for Mesh 1:\n');
for i = 1:size(scaled_fiducials1, 1)
    fprintf('Fiducial %d: (%.2f, %.2f, %.2f)\n', i, scaled_fiducials1(i, 1), scaled_fiducials1(i, 2), scaled_fiducials1(i, 3));
end

fprintf('Fiducial coordinates for Mesh 2 (before ICP transformation):\n');
for i = 1:size(scaled_fiducials2, 1)
    fprintf('Fiducial %d: (%.2f, %.2f, %.2f)\n', i, scaled_fiducials2(i, 1), scaled_fiducials2(i, 2), scaled_fiducials2(i, 3));
end

fprintf('Fiducial coordinates for Mesh 2 (after ICP transformation):\n');
for i = 1:size(transformed_fids2, 1)
    fprintf('Fiducial %d: (%.2f, %.2f, %.2f)\n', i, transformed_fids2(i, 1), transformed_fids2(i, 2), transformed_fids2(i, 3));
end

% visualise 
figure;
hold on;

trisurf(mesh1_ds_scaled.faces, mesh1_ds_scaled.vertices(:,1), mesh1_ds_scaled.vertices(:,2), mesh1_ds_scaled.vertices(:,3), ...
    'FaceColor', 'cyan', 'FaceAlpha', 0.5, 'EdgeColor', 'none');

trisurf(mesh2_final.faces, mesh2_final.vertices(:,1), mesh2_final.vertices(:,2), mesh2_final.vertices(:,3), ...
    'FaceColor', 'magenta', 'FaceAlpha', 0.5, 'EdgeColor', 'none');

trisurf(spinalcord_ds_scaled.faces, aligned_spine_points(:,1), aligned_spine_points(:,2), aligned_spine_points(:,3), ...
   'FaceColor', 'black',   'FaceAlpha', 1, 'EdgeColor', 'none');

scatter3(scaled_fiducials1(:,1), scaled_fiducials1(:,2), scaled_fiducials1(:,3), 100, 'r', 'filled', 'MarkerEdgeColor', 'k');
for i = 1:size(scaled_fiducials1, 1)
    text(scaled_fiducials1(i,1), scaled_fiducials1(i,2), scaled_fiducials1(i,3), sprintf('Fid1 %d', i), 'Color', 'r', 'FontSize', 12);
end

scatter3(transformed_fids2(:,1), transformed_fids2(:,2), transformed_fids2(:,3), 100, 'b', 'filled', 'MarkerEdgeColor', 'k');
for i = 1:size(transformed_fids2, 1)
    text(transformed_fids2(i,1), transformed_fids2(i,2), transformed_fids2(i,3), sprintf('Fid2 %d', i), 'Color', 'b', 'FontSize', 12);
end

title('Final Alignment with ICP on Fiducials');
axis equal;
view(3);
camlight;
lighting gouraud;
hold off;

% Combine with Dipoles from HPI Coil + Neck Cast Sensor Array
% Load and Import Sensors Array and Dipole Fit
addpath('D:\OPM\sub-OP00169\ses-001\meg\');
load('dipole_sensor_data.mat', 'dip20', 'dip40', 'sensors','grad');

dip20_pos = dip20.dip.pos * scale_factor; 
dip20_mom = dip20.dip.mom; 
dip20_max_mom = max(dip20_mom, [], 2)'; 


dip40_pos = dip40.dip.pos * scale_factor;
dip40_mom = dip40.dip.mom; 
dip40_max_mom = max(dip40_mom, [], 2)';

sensor_positions = sensors.chanpos * scale_factor; 
sensor_orientations = sensors.chanori;
sensor_labels = sensors.label;
Select C7 and Inion on MRI to combine with HPI data
fprintf('Select fiducials on MRI (C7 and Inion)\n');
mri_fiducials = spm_mesh_select(mesh2_final, 2);
mri_fids = mri_fiducials';

% allign dipoles and sensor array with MRI fids - treat dipole and sensor array as one rigid structure to ensure no change in location of the dipoles relative to the sensor array
[d, Z, transform] = procrustes(mri_fids, [dip20_pos; dip40_pos], 'Scaling', false, 'Reflection', true);
aligned_dipole_pos = [dip20_pos; dip40_pos] * transform.T + transform.c(1,:);
aligned_dip20_pos = aligned_dipole_pos(1, :);
aligned_dip40_pos = aligned_dipole_pos(2, :);

aligned_dip20_mom = dip20_max_mom * transform.T;
aligned_dip40_mom = dip40_max_mom * transform.T;

aligned_sensor_positions = sensor_positions * transform.T + transform.c(1,:);  

% rotate sensor array around the axis formed between the two MRI fids - ensuring no sensor position is 'inside' the co-registered scans
axis_of_rotation = mri_fids(2, :) - mri_fids(1, :);
axis_of_rotation = axis_of_rotation / norm(axis_of_rotation); %normalised

O = mri_fids(1, :); % Origin point (use first MRI fiducial - C7)

combined_positions = [aligned_sensor_positions; aligned_dip40_pos; aligned_dip20_pos];

min_intersections = Inf;
best_combined_positions = combined_positions;

for theta = 230:1:360 %i know roughly the angle is around 270 so for now i can look between 230 and 360 - but for a new data set will need to change this!
    fprintf('Processing angle: %d degrees\n', theta);

    rotated_combined_positions = zeros(size(combined_positions));
    
    % Iterate through each position separately
    for i = 1:size(combined_positions, 1)
        v = combined_positions(i, :);
        ov = v - O; % Vector to be rotated
        
        % Rodrigues' rotation formula - code adapted from one on MATLAB
        % file exchange (Rodrigues' axis-angle rotation by Soumitra Sitole)
        v_rot = ov * cosd(theta) + cross(axis_of_rotation, ov) * sind(theta) + axis_of_rotation * (dot(axis_of_rotation, ov)) * (1 - cosd(theta));
        
        rotated_combined_positions(i, :) = v_rot + O;
    end
    
    % Split back into sensor positions and dipole positions
    rotated_sensor_positions = rotated_combined_positions(1:size(sensor_positions, 1), :);
    
    num_intersections = check_intersections(rotated_sensor_positions, mesh2_final);
    if num_intersections < min_intersections
        min_intersections = num_intersections;
        best_combined_positions = rotated_combined_positions;
    end

    if min_intersections == 0
        break;
    end
end


best_sensor_positions = best_combined_positions(1:size(sensor_positions, 1), :);
best_dip20_pos = best_combined_positions(size(sensor_positions, 1) + 1, :);
best_dip40_pos = best_combined_positions(size(sensor_positions, 1) + 2, :);

best_dip20_mom = aligned_dip20_mom * theta;
best_dip40_mom = aligned_dip40_mom * theta;
visualise
figure;
hold on;

h_optical = trisurf(mesh1_ds_scaled.faces, mesh1_ds_scaled.vertices(:,1), mesh1_ds_scaled.vertices(:,2), mesh1_ds_scaled.vertices(:,3), ...
    'FaceColor', 'cyan', 'FaceAlpha', 0.5, 'EdgeColor', 'none', 'DisplayName', 'Optical Scan');

h_mri = trisurf(mesh2_final.faces, mesh2_final.vertices(:,1), mesh2_final.vertices(:,2), mesh2_final.vertices(:,3), ...
    'FaceColor', 'magenta', 'FaceAlpha', 0.5, 'EdgeColor', 'none', 'DisplayName', 'MRI');

h_spine = trisurf(spinalcord_ds_scaled.faces, aligned_spine_points(:,1), aligned_spine_points(:,2), aligned_spine_points(:,3), ...
   'FaceColor', 'black',   'FaceAlpha', 1, 'EdgeColor', 'none');

h_dip20 = ft_plot_dipole(best_dip20_pos, best_dip20_mom, 'length', 0, 'diameter', 0.1, 'unit', 'mm', 'colour', 'r');

h_dip40 = ft_plot_dipole(best_dip40_pos, best_dip40_mom, 'length', 0, 'diameter', 0.1, 'unit', 'mm', 'colour', 'm');

h_sensors = scatter3(best_sensor_positions(:,1), best_sensor_positions(:,2), best_sensor_positions(:,3), ...
    100, 'y', 'filled', 'MarkerEdgeColor', 'k');

h_fids = scatter3(mri_fids(:,1), mri_fids(:,2), mri_fids(:,3), 100, 'g', 'filled', 'MarkerEdgeColor', 'k');

title('Alligned MRI with Optical Scan Co-Registered to HPI Coils within OPM Sensor Array');

legend([h_optical, h_mri, h_spine, h_dip20(1), h_dip40(1), h_sensors, h_fids], ...
    {'Optical Scan', 'MRI', 'Spinal Cord', 'Dipole for 20Hz', 'Dipole for 40Hz', 'Sensor Array', 'MRI Fiducials'});


axis equal;
view(3);
camlight;
lighting gouraud;
hold off;
